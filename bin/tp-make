#!/usr/bin/env ruby

require 'optparse'
require 'typingpool'
require 'fileutils'
require 'set'

options = {
  :config => Typingpool::Config.file,
  :files => [],
  :voices => [],
  :unusual => [],
  :chunk => '1:00',
}
OptionParser.new do |opts|
  options[:banner] = opts.banner = "USAGE: #{File.basename($PROGRAM_NAME)} PROJECTNAME FILE [FILE [FILE...]]\n  [--title PROJECTNAME] [--file foo.mp3 [--file bar.mp3...]]\n  [--chunks 1:00] [--subtitle 'Hack Day interview']\n  [--voice 'John' --voice 'Pat Foo, British female'...]\n  [--unusual 'Hack Day' --unusual 'Sunnyvale, Chad Dickerson'...]\n  [--bitrate 256][--moveorig] [--config PATH]\n"

  opts.on('--title TITLE', 'Required. For file names and transcript.', '  Also accepted as first argument') do |title|
    options[:title] = title
  end

  opts.on('--file FILE', 'Required. Audio for transcribing.', '  Repeatable (sorting is by name).', '  Also accepted as second and later arguments') do |file|
    options[:files].push(file)
  end

  opts.on('--subtitle SUBTITLE', 'For transcript') do |subtitle|
    options[:subtitle] = subtitle
  end

  opts.on('--chunks MM:SS', 'Default: 1:00. Audio divided thusly for transcribing.', '  Try also HH:MM:SS.ss and SSS') do |chunk|
    options[:chunk] = chunk
  end

  opts.on('--voice "NAME[, DESCR]"', 'Name, optional description of recorded person, to aid transcriber.', '  Repeatable') do |voice|
    options[:voices].push(voice)
  end

  opts.on('--unusual WORD[,WORD,]', 'Unusual word within recording, to aid transcriber.', '  Commas for multiple. Repeatable') do |word|
    options[:unusual].push(word)
  end

  opts.on('--config PATH', 'Default: ~/.typingpool. A config file') do |config|
    path = File.expand_path(config)
    File.exists?(path) && File.file?(path) or abort "No such file #{path}"
    options[:config] = Typingpool::Config.file(config)
  end

  opts.on('--bitrate KBPS', 'Default: Mirror input. Output bitrate in kb/s.', '  Only applies if/when converting to MP3') do |kbps|
    options[:bitrate] = kbps
  end

  opts.on('--moveorig', 'Move input files instead of copying.') do
    options[:moveorig] = true
  end

  opts.on('--help', 'Display this screen.') do
    puts opts
    exit
  end
end.parse!
options[:title] ||= ARGV.shift if not(ARGV.empty?)
options[:files].push(ARGV).flatten! if not(ARGV.empty?)
options[:banner] += "\n`#{File.basename($PROGRAM_NAME)} --help` for more information.\n"
abort "No files specified\n\n#{options[:banner]}" if options[:files].empty?
abort "No title specified\n\n#{options[:banner]}" if options[:title].to_s.empty?
options[:files].sort!
options[:files].each do |file|
  File.extname(file) or abort "You need a file extension on the file '#{file}'"
  File.exist?(file) or abort "There is no file '#{file}'"
end

config = options[:config]

options[:unusual].map!{|unusual| unusual.split(/\s*,\s*/)}.flatten!
options[:voices].map! do |voice| 
  name, description = voice.split(/\s*,\s*/)
  {
    :name => name,
    :description => (description || '')
  }
end

begin
  project = Typingpool::Project.new(options[:title], config)
rescue Typingpool::Error::Argument::Format
  abort "Invalid title '#{options[:title]}'. Title must be a valid directory name. Eliminate '/' or any other illegal character."
end #begin

begin
  project.interval = options[:chunk] if options[:chunk]
rescue Typingpool::Error::Argument::Format
  abort "Could not make sense of chunk argument '#{options[:chunk]}'. Required format is SS, or MM:SS, or HH:MM:SS, with optional decimal values (e.g. MM:SS.ss)"
end #begin

begin
  project.bitrate = options[:bitrate] if options[:bitrate]
rescue Typingpool::Error::Argument::Format
  abort "Could not make sense of bitrate argument '#{options[:bitrate]}'. Should be an integer corresponding to kb/s."
end #begin

files = nil
remote_files=nil
urls = nil
audio_upload_confirms = []
if project.local
  if not( File.exists?(project.local.csv('data', 'assignment.csv')) && 
          project.local.csv('data', 'assignment.csv').read.select{|assignment| assignment['audio_upload_confirmed'].to_i == 0 }.count > 0)
    #successfully made project
    abort "The title '#{options[:title]}' is taken"
  end
  #project where the upload died partway through
  STDERR.puts "Fixing incomplete project"
  if options[:files]
    project_files = Set.new(project.local.subdir('audio', 'originals').files.map{|file| file.path })
    if not( (options[:files].count == project_files.count) &&
            (options[:files].reject{|file| project_files.include? file }))
      abort "Files submitted don't match files originally used to build the project. If you want to re-build the project with new files, run tp-finish PROJECTPATH, then rm -r or rename the project folder, and call tp-make again with the same args."
    end
  end
  STDERR.puts "Determining which mp3s need uploading"
  urls = []
  assignments_not_uploaded = []
  project.local.csv('data', 'assignment.csv').each do |assignment|
    urls.push(assignment['audio_url'])
    STDERR.puts "Testing #{assignment['audio_url']}"
    if ( (assignment['audio_upload_confirmed'].to_i == 0) && (not(Typingpool::Utility.working_url? assignment['audio_url'])) )
      assignments_not_uploaded.push(assignment)
      audio_upload_confirms.push(0)
    else
      audio_upload_confirms.push(1)
    end #if ((assignment['audio_upload_confirmed'].to_i == 0...
  end #project.local.csv('data', 'assignment.csv').each...
  remote_files = assignments_not_uploaded.map{|assignment| project.remote.url_basename(assignment['audio_url']) }
  files = assignments_not_uploaded.map{|assignment|  Typingpool::Project.local_basename_from_url(assignment['audio_url']) }.map{|basename| project.local.file('audio', 'chunks', basename) }
  files = Typingpool::Filer::Files.new(files)
else
  project.create_local

  options[:files].each{|path| FileUtils.cp(path, project.local.subdir('audio', 'originals')) }

  files = project.local.subdir('audio', 'originals').as(:audio).to_mp3(project.local.subdir('etc','tmp'), project.bitrate) do |file| 
    puts "Converting #{File.basename(file) } to mp3" 
  end

  puts "Merging audio" if files.count > 1
  file = files.merge(project.local.audio('audio', "#{project.name}.all.mp3"))

  puts "Splitting audio into uniform bits"
  files = file.split(project.interval_as_min_dot_sec, File.basename(file, '.*').sub(/\.all$/, ''), project.local.subdir('audio','chunks'))

  remote_files = project.create_remote_names(files)
  urls = remote_files.map{|file| project.remote.file_to_url(file) }
  audio_upload_confirms = urls.map{ 0 }
end #if project.local


project.local.subtitle = options[:subtitle] if options[:subtitle]

#Write mp3 URLs before uploading, so we can rollback if uploading dies
#halfway through
assignment_path = project.create_assignment_csv(:path => ['data', 'assignment.csv'], :urls => urls, :chunk => options[:chunk], :unusual => options[:unusual], :voices => options[:voices], :audio_upload_confirms => audio_upload_confirms)
puts "Wrote #{assignment_path}"
project.local.audio_is_on_www = 'yes'
remote_files = project.remote.put(files.to_streams, remote_files) do |file, as|
  puts "Uploading #{File.basename(file)} to #{project.remote.host}/#{project.remote.path} as #{as}"
end
project.local.csv('data', 'assignment.csv').each!{|assignment| assignment['audio_upload_confirmed'] = 1 }

if STDOUT.tty?
  puts "Opening project folder #{project.local.path}"
  project.local.finder_open 
end

puts "Deleting temp files"
FileUtils.rm_r(project.local.subdir('etc', 'tmp'))

puts "Done"
