#!/usr/bin/env ruby

require 'typingpool'
require 'text/format'
require 'highline/import'
require "highline/system_extensions"
include HighLine::SystemExtensions

options = {
  :config => Typingpool::Config.file
}

OptionParser.new do |commands|
  options[:banner] = commands.banner = "USAGE: #{File.basename($PROGRAM_NAME) } PROJECT|--all\n  [--config PATH] [--sandbox]\n"
  commands.on('--project=PROJECT', 'Path or name within dir $config_file:transcripts.', '  Also accepted as first argument to script.', '  Either PROJECT or --all must be specified') do |project|
    options[:project] = project
  end
  commands.on('--all', 'Review pending results for ANY project') do |all|
    options[:all] = true
  end
  commands.on('--config=PATH', 'Default: ~/.typingpool') do |path|
    path = File.expand_path(path)
    File.exists?(path) && File.file?(path) or abort "No such file #{path}"
    options[:config] = Typingpool::Config.file(path)
  end
  commands.on('--sandbox', 'Test in Mechanical Turk\'s sandbox') do |sandbox|
    options[:sandbox] = true
  end
  commands.on('--help', "Display this screen") do
    STDERR.puts commands
    exit
  end
end.parse!

options[:banner] += "`#{File.basename($PROGRAM_NAME)} --help` for more information.\n"

if ARGV[0]
  if options[:project]
    abort "Duplicate project values ('#{ARGV[0]}' and '#{options[:project]}')"
  end
  options[:project] = ARGV[0]
elsif not (options[:project] || options[:all])
  abort "Neither a project nor --all specified\n#{options[:banner]}"
end

if options[:project]
  if File.exists? options[:project]
    options[:config].transcripts = File.dirname(options[:project])
  else
    if not(options[:config].transcripts)
      abort "No 'transcripts' dir specified in your config file and #{options[:project]} is not a valid path"
    end
    options[:project] = File.join(options[:config].transcripts, options[:project])
    if not(File.exists? options[:project])
      abort "No such project #{File.basename(options[:project])} in dir #{File.dirname(options[:project])}"
    end
  end
  if not(File.directory? options[:project])
    abort "Project is not a directory at #{options[:project]}"
  end
end

hits = Typingpool::Amazon::HIT.all_reviewable{|hit| hit.submitted? && hit.ours? }
if options[:project]
  hits.select!{|hit| hit.project_id == options[:project].local.id }
end
hits.sort!{|a, b| a.url <=> b.url }

formatter = Text::Format.new
formatter.first_indent = 2
formatter.body_indent = 2
choices = %w(approve reject quit skip)
hits.each do |hit|
  say(HighLine.color("Transcript for #{hit.url}#", :reverse))
  say(HighLine.color("Submitted at #{hit.assignment.submitted_at} by #{hit.assignment.worker_id}", :bold))
  say(formatter.format(hit.assignment.body))
  prompt = choices.map{|c| HighLine.color('(', :reverse) + HighLine.color(c.slice(0).upcase, :bold, :reverse) + HighLine.color(")#{c.slice(1, c.size)}", :reverse) }
  prompt << HighLine.color('[', :reverse) + formatted.pop + HighLine.color(']', :reverse)
  prompt = prompt.join(HighLine.color(', ', :reverse)) + HighLine.color('? ', :reverse)
  say(prompt)

  choice=nil
  until choice
    input = get_character.chr
    if input.to_s.match(/^\s*$/)
      choice = choices.last
    elsif not(choice = choices.detect{|possible| possible[0] == input.downcase })
      say("Invalid selection '#{input}'.")
      say(prompt)
    end
  end #until choice

  case choice
  when 'approve'
    hit.assignment.approve!
    say(HighLine.color("Approved", :bold))
  when 'reject'
    reason=nil
    until reason.match(/\S/)
      reason = ask("Rejection reason, for worker: ")
    end
    hit.assignment.reject!(reason)
  when 'quit'
    exit
  when 'skip'
    next
  end
end
