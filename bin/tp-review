#!/usr/bin/env ruby

require 'typingpool'
require 'highline/import'
require 'optparse'

options = {}
OptionParser.new do |commands|
  options[:banner] =  "USAGE: #{File.basename($PROGRAM_NAME) } [PROJECT]\n"
  options[:banner] += "  [--config PATH] [--sandbox]\n"
  commands.banner = options[:banner]

  commands.on('--project=PROJECT',
              'Path or name within dir $config_file:transcripts.',
              'Also accepted as first argument to script.',
              'If not specified, reviews pending results',
              'for ALL projects') do |project|
    options[:project] = project
  end
  commands.on('--config=PATH',
              'Default: ~/.typingpool') do |path|
    options[:config] = path
  end
  commands.on('--sandbox',
              'Test in Mechanical Turk\'s sandbox') do |sandbox|
    options[:sandbox] = true
  end
  commands.on('--fixture=PATH',
              "Optional. For testing purposes only.",
              "A VCR fixture for running with mock data") do |fixture|
    options[:fixture] = fixture
  end
  commands.on('--help',
              "Display this screen") do
    STDERR.puts commands
    exit
  end
end.parse!

config = Typingpool::App::CLI.config_from_arg(options[:config]) or abort "No config file at '#{options[:config]}'"
options[:banner] += "\n#{Typingpool::App::CLI.help_arg_explanation}\n"

if ARGV.count > 0
  if options[:project]
    abort "Duplicate project values ('#{ARGV[0]}' and '#{options[:project]}')"
  end
  options[:project] = ARGV.shift
end
abort "Unexpected argument(s): #{ARGV.join(';')}" if ARGV.count > 0

if options[:project]
  options[:project] = Typingpool::App::CLI.project_from_arg_and_config(options[:project], config)
end

if options[:fixture]
  Typingpool::App.vcr_record(options[:fixture], config)
end

Typingpool::Amazon.setup(:sandbox => options[:sandbox], :config => config)

assignments = Typingpool::App.assignments_file_for_sandbox_status(options[:sandbox], options[:project]) if options[:project]
STDERR.puts "Gathering submissions from Amazon"
hits = if options[:project] && ((hit_ids = assignments.map{|assignment| assignment['hit_id'] }.select{|hit_id| hit_id }).count > 0)
         Typingpool::Amazon::HIT.with_ids(hit_ids).select{|hit| hit.submitted? }
       else
         hits = Typingpool::Amazon::HIT.all_reviewable{|hit| hit.submitted? && hit.ours? }
         if options[:project]
           #code path for projects assigned through RUI
           hits.select!{|hit| hit.project_id == options[:project].local.id }
         end
         hits
       end

STDERR.puts "Matching submissions with local projects"
choices = %w(approve reject quit skip)
catch :quitting do
  project_hits = Typingpool::App.find_projects_waiting_for_hits(hits, config) 
  all_hits = project_hits.map{|hash| hash[:hits] }.flatten
  i = 0
  project_hits.each do |hash|
    hits = hash[:hits]
    project = hash[:project]
    assignments = Typingpool::App.assignments_file_for_sandbox_status(options[:sandbox], project)
    hits.sort!{|a, b| a.url <=> b.url }
    hits.each do |hit|
      i += 1
      say(HighLine.color("Transcript for: ", :bold) + hit.url)
      project_info = HighLine.color("Project: ", :bold) + project.name
      if project.local.subtitle
        project_info += ": #{project.local.subtitle}"
      end
      say(project_info)
      say(HighLine.color("Submitted at: ", :bold) +
          hit.assignment.submitted_at.localtime.to_s +
          HighLine.color(" by ", :bold) +
          hit.assignment.worker_id)
      say(hit.transcript.body_as_text do |formatter|
            formatter.first_indent = 2
            formatter.body_indent = 2
          end)
      prompt = choices.map do |c| 
        HighLine.color('(', :reverse) +
          HighLine.color(c.slice(0).upcase, :bold, :reverse) +
          HighLine.color(")#{c.slice(1, c.size)}", :reverse) 
      end
      prompt << HighLine.color('[', :reverse) + prompt.pop + HighLine.color(']', :reverse)
      prompt = prompt.join(HighLine.color(', ', :reverse)) 
      prompt += HighLine.color('? ', :reverse)
      prompt += HighLine.color("(#{i}/#{all_hits.count}) ", :reverse)

      choice=nil
      until choice
        input = ask(prompt)
        if input.to_s.match(/^\s*$/)
          choice = choices.last
        elsif not(choice = choices.detect{|possible| possible[0] == input.downcase[0] })
          say("Invalid selection '#{input}'.")
        end
      end #until choice

      case choice
      when 'approve'
        hit.assignment.at_amazon.approve!
        Typingpool::App.record_approved_hits_in_assignments_file(assignments, [hit])
        Typingpool::App.create_transcript(project, assignments)
        say(HighLine.color("Approved. ", :bold) + "#{project.name} transcript updated.")
      when 'reject'
        reason=nil
        until reason.to_s.match(/\S/)
          reason = ask("Rejection reason, for worker: ")
        end
        hit.assignment.at_amazon.reject!(reason)
        hit.at_amazon.dispose!
        Typingpool::App.unrecord_hits_in_assignments_file(assignments, [hit])
        say(HighLine.color("Rejected", :bold))
      when 'quit'
        say(HighLine.color("Quitting", :bold))
        throw :quitting
      when 'skip'
        say(HighLine.color("Skipping", :bold))
        next
      end #case choice
    end #hits.each_with_index

  end #find_projects_waiting_for(...) do
end #catch :quitting do

if options[:fixture]
  Typingpool::App.vcr_stop
end
